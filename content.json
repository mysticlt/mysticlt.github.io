{"meta":{"title":"MysticLt的博客","subtitle":"微笑着面对困难","description":null,"author":"Mystic Lt","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"构造函数和原型","slug":"构造函数和原型","date":"2019-11-11T07:45:40.000Z","updated":"2019-11-11T09:49:45.869Z","comments":true,"path":"2019/11/11/构造函数和原型/","link":"","permalink":"http://yoursite.com/2019/11/11/构造函数和原型/","excerpt":"","text":"12构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。function Fn () &#123;&#125; 在JS 中，使用构造函数时要注意以下两点： 如果用new，就是构造函数，否则就是普不函数 1.构造函数用于创建某一类对象，其首字母要大写 2.构造函数要和new 一起使用才有意义 1练习判断构造函数还是普通函数 new在执行时会做四件事情 在内存中创建一个新的空对象。 让this指向这个新的对象。 执行构造函数里面的代码，给这个新对象添加属性和方法。 返回这个新对象（所以构造函数里面不需要return）。 静态成员和实例成员1JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。 静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 1234567891011121314151617function Person (uname, age) &#123; this.uname = uname; this.age = age; this.say = function () &#123; console.log(123); &#125;&#125; var obj = new Person('张三丰',22); console.log(obj.uname); // console.log( Person.uname ); Person.leibie = '人'; console.log(Person.leibie); console.log(obj.leibie); 构造函数小问题： 1234567当实例化对象的时候，属性好理解，属性名属性值，那么方法是函数，函数是复杂数据类型那么保存的时候是保存地址，又指向函数，而每创建一个对象，都会有一个函数，每个函数都得开辟一个内存空间，此时浪费内存了，那么如何节省内存呢，我们需要用到原型方法放到构造函数里面，如果多次实例化，会浪费内存 12345678910function Star (uname, age) &#123; this.uname = uname; this.age = age; this.sing = function () &#123; console.log(this.name + &apos;在唱歌&apos;); &#125;&#125;var ldh = new Star(&apos;周星驰&apos;, 22);var ldh = new Star(&apos;刘德华&apos;, 22); 构造函数原型prototype什么是原型对象：就是一个属性，是构造函数的属性，这个属性是一个对象，我们也称呼，prototype 为原型对象。 每一个构造函数都有一个属性，prototype 作用：是为了共享方法，从而达到节省内存 注意：每一个构造函数都有prototype属性 例如：大家来学校上学，有的开车，有的汽车，有的开飞机，等等，此时浪费，那么准备一个大巴车，方便有节省 构造函数通过原型分配的函数是所有对象所共享的。 JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。我们可以把那些不变的方法，直接定义在prototype 对 象上，这样所有对象的实例就可以共享这些方法。 123456789101112131415161718function Star (uname, age) &#123;​ this.uname = uname;​ this.age = age;​ // this.sing = function () &#123;​ // console.log(this.name + '在唱歌');​ // &#125;​ &#125;​ Star.prototype.sing = function () &#123;​ console.log(this.uname + '在唱歌');​ &#125;​ var zxc = new Star('周星驰', 22);​ var ldh = new Star('刘德华', 22);​ // console.log( Star.prototype );​ ldh.sing();​ zxc.sing(); 总结：所有的公共属性写到构造函数里面，所有的公共方法写到原型对象里面 疑问：为何创建一个对象，都可以自动的跑到原型对象上找方法 因为每一个对象都有一个属性，对象原型，执行原型对象 对象原型：proto主要作用：指向prototype 构造函数和原型对象都会有一个属性proto 指向构造函数的prototype 原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有proto 原型的存在。 12&gt; 注意：____proto____是一个非标准属性，不可以拿来赋值或者设置【只读属性】&gt; 1231.____proto____对象原型和原型对象prototype 是等价的2.____proto____对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype 总结：每一个对象都有一个原型，作用是指向原型对象prototype 统一称呼：proto原型，prototype成为原型对象 【每一个构造函数都有：原型对象】 【每一个实例对象都有：对象原型】 constructor 构造函数 记录是哪个构造函数创建出来的 指回构造函数本身 原型（proto）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor 我们称为构造函数，因为它指回构造函数本身。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor 指向原来的构造函数。 总结：constructor 主要作用可以指回原来的构造函数 构造函数、实例、原型对象三者之间的关系 思考：如果传入一个对象给原型对象添加方法呢 1234567Star.prototype = &#123; sing : function () &#123;&#125;, dance: function () &#123;&#125;&#125;;此时会覆盖原先prototype中的内容，传入一个新的对象，那么此时就不知道构造函数是哪个了所以我们要指回构造函数：constructor：构造函数 原型链1作用：提供一个成员的查找机制，或者查找规则 JavaScript 的成员查找机制(规则)123456789101112当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。如果没有就查找它的原型（也就是__proto__指向的prototype 原型对象）。如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。// console.log(Star.prototype.__proto__.__proto__);// console.log(Object.prototype); 扩展内置对象1可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。 123456789101112131415console.log( Array.prototype ); // 添加求和方法 Array.prototype.sum = function () &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum; &#125; var arr = [1,2,3]; console.log( arr.sum() ); var newArr = [6,7,8,9]; console.log( newArr.sum() ); 构造函数：function Fn () {} 属性写到构造函数里面，方法写到构造函数的原型对象里面 原型对象：每一个构造函数都有原型对象【prototype】【作用是用来保存方法】 对象原型：每一个对象都有一个对象原型（原型）【proto】【作用是指向原型对象】 constructor：指向构造函数 原型链：作用是查找属性或者方法方向，机制 构造函数：function Fn () {} 静态成员实例成员：函数内部，在构造函数上 原型对象： 构造函数属性prototype【把方法都放到原型对象】 对象原型：指向原型对象【proto】 constructor：构造函数 原型链：原型，查找属性或者方法提供的机制 构造函数，实例对象，原型对象","categories":[],"tags":[{"name":"构造函数和原型","slug":"构造函数和原型","permalink":"http://yoursite.com/tags/构造函数和原型/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-20T10:42:10.940Z","updated":"2019-09-20T10:42:10.941Z","comments":true,"path":"2019/09/20/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}